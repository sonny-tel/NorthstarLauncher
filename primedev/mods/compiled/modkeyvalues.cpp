#include "mods/modmanager.h"
#include "core/filesystem/filesystem.h"
#include "core/vanilla.h"

#include <fstream>

void ModManager::ProcessConditionalBlocks(const fs::path& filePath, bool keepNorthstar)
{
    std::ifstream inFile(filePath, std::ios::binary);
    if (!inFile)
        return;

    std::ostringstream processed;
    std::string line;
    bool inConditional = false;
    bool keepBlock = true;

    while (std::getline(inFile, line))
    {
        if (!line.empty() && line.back() == '\r')
            line.pop_back();

        if (line.find("///if VANILLA") != std::string::npos)
        {
            inConditional = true;
            keepBlock = !keepNorthstar;
            continue;
        }
        else if (line.find("///if NORTHSTAR") != std::string::npos)
        {
            inConditional = true;
            keepBlock = keepNorthstar;
            continue;
        }
        else if (line.find("///endif") != std::string::npos)
        {
            inConditional = false;
            keepBlock = true;
            continue;
        }

        if (!inConditional || keepBlock)
            processed << line << "\n";
    }
    inFile.close();

    std::ofstream outFile(filePath, std::ios::binary | std::ios::trunc);
    outFile << processed.str();
    outFile.close();
}

void ModManager::TryChangeoverKeyValues(const char* filename, ModOverrideFile& modFile)
{
	if( g_pVanillaCompatibility->GetVanillaCompatibility() == (modFile.m_lastCompatibilityMode == VanillaCompatibility::CompatibilityMode::Vanilla) )
		return;

	spdlog::info("Trying to changeover KeyValues for file {}", filename);

	fs::path compiledPath = GetCompiledAssetsPath() / filename;
	fs::path compiledDir = compiledPath.parent_path();

	modFile.m_lastCompatibilityMode = g_pVanillaCompatibility->GetVanillaCompatibility() ?
		VanillaCompatibility::CompatibilityMode::Vanilla : VanillaCompatibility::CompatibilityMode::Northstar;

	std::ofstream writeStream(compiledPath, std::ios::binary);

	std::string newKvs = "// AUTOGENERATED: MOD PATCH KV\n";

	std::vector<std::string>& patchesVec = g_pVanillaCompatibility->GetVanillaCompatibility() ? modFile.m_VanillaKeyvaluePaths : modFile.m_NorthstarKeyvaluePaths;

	fs::path kvPath(filename);
	std::string ogFilePath = "mod_original_";
	ogFilePath += kvPath.filename().string();

	for( auto& patchFilePath : patchesVec )
	{
		if (fs::exists(compiledDir / patchFilePath))
		{
			newKvs += "#base \"";
			newKvs += patchFilePath;
			newKvs += "\"\n";
		}
		else
		{
			spdlog::warn("Patch file {} does not exist, skipping.", patchFilePath);
			continue;
		}
	}

	newKvs += "#base \"";
	newKvs += ogFilePath;
	newKvs += "\"\n";

	writeStream << newKvs;
	writeStream.close();
}

void ModManager::TryBuildKeyValues(const char* filename)
{
	spdlog::info("Building KeyValues for file {}", filename);

	std::string normalisedPath = g_pModManager->NormaliseModFilePath(fs::path(filename));
	fs::path compiledPath = GetCompiledAssetsPath() / filename;
	fs::path compiledDir = compiledPath.parent_path();
	fs::create_directories(compiledDir);

	fs::path kvPath(filename);
	std::string ogFilePath = "mod_original_";
	ogFilePath += kvPath.filename().string();

	std::string newKvs = "// AUTOGENERATED: MOD PATCH KV\n";

	int patchNum = 0;

	ModOverrideFile overrideFile;

	// copy over patch kv files, and add #bases to new file, last mods' patches should be applied first
	// note: #include should be identical but it's actually just broken, thanks respawn
	for (int64_t i = m_LoadedMods.size() - 1; i > -1; i--)
	{
		if (!m_LoadedMods[i].m_bEnabled)
			continue;

		size_t fileHash = STR_HASH(normalisedPath);
		auto modKv = m_LoadedMods[i].KeyValues.find(fileHash);
		if (modKv != m_LoadedMods[i].KeyValues.end())
		{
			// should result in smth along the lines of #include "mod_patch_5_mp_weapon_car.txt"

			constexpr const char* patchPrefix = "mod_patch_";
			patchNum++;

			std::string vanillaPatchPath = std::string(patchPrefix) + std::to_string(patchNum++) + "_v_" + kvPath.filename().string();
			std::string northstarPatchPath = std::string(patchPrefix) + std::to_string(patchNum++) + "_n_" + kvPath.filename().string();
			std::string& patchFilePath =
				(g_pVanillaCompatibility->GetVanillaCompatibility() ? vanillaPatchPath : northstarPatchPath);

			newKvs += "#base \"";
			newKvs += patchFilePath;
			newKvs += "\"\n";

			overrideFile.m_VanillaKeyvaluePaths.push_back(vanillaPatchPath);
			overrideFile.m_NorthstarKeyvaluePaths.push_back(northstarPatchPath);

			fs::remove(compiledDir / vanillaPatchPath);
			fs::remove(compiledDir / northstarPatchPath);

			fs::copy_file(m_LoadedMods[i].m_ModDirectory / "keyvalues" / filename, compiledDir / vanillaPatchPath);
			fs::copy_file(m_LoadedMods[i].m_ModDirectory / "keyvalues" / filename, compiledDir / northstarPatchPath);

			ProcessConditionalBlocks(compiledDir / vanillaPatchPath, false);
			ProcessConditionalBlocks(compiledDir / northstarPatchPath, true);
		}
	}

	// add original #base last, #bases don't override preexisting keys, including the ones we've just done
	newKvs += "#base \"";
	newKvs += ogFilePath;
	newKvs += "\"\n";

	// load original file, so we can parse out the name of the root obj (e.g. WeaponData for weapons)
	std::string originalFile = ReadVPKOriginalFile(filename);

	if (!originalFile.length())
	{
		spdlog::warn("Tried to patch kv {} but no base kv was found!", ogFilePath);
		return;
	}

	char rootName[64];
	memset(rootName, 0, sizeof(rootName));

	// iterate until we hit an ascii char that isn't in a # command or comment to get root obj name
	int i = 0;
	while (!(originalFile[i] >= 65 && originalFile[i] <= 122))
	{
		// if we hit a comment or # thing, iterate until end of line
		if (originalFile[i] == '/' || originalFile[i] == '#')
			while (originalFile[i] != '\n')
				i++;

		i++;
	}

	int j = 0;
	for (int j = 0; originalFile[i] >= 65 && originalFile[i] <= 122; j++)
		rootName[j] = originalFile[i++];

	// empty kv, all the other stuff gets #base'd
	newKvs += rootName;
	newKvs += "\n{\n}\n";

	std::ofstream originalFileWriteStream(compiledDir / ogFilePath, std::ios::binary);
	originalFileWriteStream << originalFile;
	originalFileWriteStream.close();

	std::ofstream writeStream(compiledPath, std::ios::binary);
	writeStream << newKvs;
	writeStream.close();

	overrideFile.m_pOwningMod = nullptr;
	overrideFile.m_Path = normalisedPath;
	overrideFile.m_lastCompatibilityMode = g_pVanillaCompatibility->GetVanillaCompatibility() ?
		VanillaCompatibility::CompatibilityMode::Vanilla : VanillaCompatibility::CompatibilityMode::Northstar;

	if (m_ModFiles.find(normalisedPath) == m_ModFiles.end())
		m_ModFiles.insert(std::make_pair(normalisedPath, overrideFile));
	else
		m_ModFiles[normalisedPath] = overrideFile;

	m_CompiledAssetFiles.insert(std::make_pair(normalisedPath, overrideFile));
}
